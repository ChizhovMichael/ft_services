1. Kubernetes — система оркестровки контейнеров с открытым исходным кодом, готовая для production и предназначенная для автоматизации размещения, масштабирования и управления контейнерами.
2. Minikube реализует локальный кластер Kubernetes в macOS, Linux и Windows.

minikube start
minikube status
kubectl get svc
kubectl apply -f <name.yaml>
kubectl get pods
kubectl get deployment
kubectl delete pods <name>
kubectl delete --all pods
kubectl logs <name>
kubectl describe pods <name>
kubectl delete -n default job <name>
kubectl delete -n default pod <name>
kubectl delete po -n metallb-system --all

3. Инструмент командной строки Kubernetes kubectl позволяет запускать команды для кластеров Kubernetes. Вы можете использовать kubectl для развертывания приложений, проверки и управления ресурсов кластера, а также для просмотра логов. Полный список операций kubectl смотрите в Overview of kubectl.

4. Pod (как стая китов или стручок гороха) - это группа из одного или нескольких контейнеров с общим хранилищем и сетевыми ресурсами и спецификацией того, как запускать контейнеры. Содержимое Pod всегда совмещено и совместно запланировано, а также выполняется в общем контексте. Pod моделирует «логический хост» для конкретного приложения: он содержит один или несколько контейнеров приложений, которые относительно тесно связаны. В не облачных контекстах приложения, выполняемые на одной физической или виртуальной машине, аналогичны облачным приложениям, выполняемым на том же логическом хосте.
Помимо контейнеров приложений, Pod может содержать контейнеры инициализации, которые запускаются во время запуска Pod. Вы также можете внедрить временные контейнеры для отладки, если ваш кластер предлагает это.
Общий контекст Pod - это набор пространств имен Linux, контрольных групп и, возможно, других аспектов изоляции - тех же вещей, которые изолируют контейнер Docker. В контексте модуля к отдельным приложениям могут применяться дополнительные частичные изоляции.
С точки зрения концепций Docker, Pod похож на группу контейнеров Docker с общими пространствами имен и общими томами файловой системы.

Вы можете использовать ресурсы рабочей нагрузки для создания и управления несколькими Pods для вас. Контроллер ресурса обрабатывает репликацию, развертывание и автоматическое восстановление в случае сбоя Pod. Например, если узел выходит из строя, контроллер замечает, что Pods на этом узле перестали работать, и создает новый Pods. Планировщик помещает заменяющий модуль на исправный узел.

5. Абстрактный способ представить приложение, работающее на наборе Pod'ов, в качестве сетевой службы.
С Kubernetes вам не нужно изменять приложение, чтобы использовать незнакомый механизм обнаружения сервисов. Kubernetes дает Pod'ам свои собственные IP-адреса и одно DNS-имя для набора Pod'ов и может распределять нагрузку между ними. 
В Kubernetes service - это абстракция, которая определяет логический набор pods и политику доступа к ним (иногда этот шаблон называется микросервисом). Pods, на которые нацелена служба, обычно определяется селектором.
Например, рассмотрим серверную часть обработки изображений без сохранения состояния, которая работает с 3 репликами. Эти реплики взаимозаменяемы - интерфейсам безразлично, какой бэкэнд они используют. Хотя фактические pods, составляющие набор серверной части, могут изменяться, клиенты внешнего интерфейса не должны знать об этом, а также не должны сами отслеживать набор серверных модулей.
Абстракция Service обеспечивает эту развязку.

6. В облачных провайдерах, которые поддерживают внешние балансировщики нагрузки, установка поля типа для LoadBalancer обеспечивает балансировщик нагрузки для вашей службы. Фактическое создание балансировщика нагрузки происходит асинхронно, а информация о подготовленном балансировщике публикуется в поле Службы .status.loadBalancer. Трафик от внешнего балансировщика нагрузки направляется на серверные модули. Облачный провайдер решает, как выполняется балансировка нагрузки. Некоторые облачные провайдеры позволяют указывать loadBalancerIP. В этих случаях балансировщик нагрузки создается с указанным пользователем loadBalancerIP. Если поле loadBalancerIP не указано, loadBalancer настроен с временным IP-адресом. Если вы указываете loadBalancerIP, но ваш облачный провайдер не поддерживает эту функцию, заданное вами поле loadbalancerIP игнорируется.

7. MetalLB - это реализация балансировщика нагрузки для кластеров Kubernetes без операционной системы, использующая стандартные протоколы маршрутизации. Kubernetes не предлагает реализацию балансировщиков сетевой нагрузки (службы типа LoadBalancer) для кластеров без операционной системы. Реализации Network LB, с которыми поставляется Kubernetes, представляют собой связующий код, который обращается к различным платформам IaaS (GCP, AWS, Azure…). Если вы не работаете на поддерживаемой платформе IaaS (GCP, AWS, Azure…), LoadBalancers будет оставаться в состоянии ожидания на неопределенный срок при создании. Операторам «Metallb» остаётся два небольших инструмента для доставки пользовательского трафика в свои кластеры: услуги «NodePort» и «externalIPs». Оба этих варианта имеют существенные недостатки для производственного использования, что делает кластеры без операционной системы второстепенными в экосистеме Kubernetes. MetalLB стремится исправить этот дисбаланс, предлагая реализацию Network LB, которая интегрируется со стандартным сетевым оборудованием, чтобы внешние сервисы на кластерах с голым железом также «просто работали» в максимально возможной степени.




Docker 

docker build -t name . (собрать image)
docker run --name aname -it -p 80:80 -p 443:443 name (собрать и запустить контейнер)
eval $(minikube docker-env) (Переключает докер на работу внутри кластера. Нужно использовать каждый раз когда открываете новый терминал)
docker exec -it <container> bash (cтарт баш в контейнере)
docker ps -a (все контейнеры)
docker ps -a | grep Exit (остановленные контейнеры)
docker start -i <container> (cтарт контейнера в интерактивном режиме)


Для старта nginx
1. adduser -D -g 'www' www
2. mkdir /www
3. chown -R www:www /var/lib/nginx
4. chown -R www:www /www
5. touch /run/openrc/softlevel
6. rc-service nginx start

rc-service nginx status


Restart minikube
1. minikube stop
2. minikube delete
3. minikube start
4. minikube addons enable metallb
5. kubectl apply -f configmap.yaml
6. eval $(minikube docker-env)
7. docker build -t name .
8. kubectl apply -f nginx.yaml
